# 科协&机器人培训笔记

这是2021届科技协会培训的笔记&2021计算机4班晚自习培训的笔记，~~禁止外传~~视频都发到B站了，也不用保密了。

## 2021.10.4

**BV1sU4y1w7te**

 第一次培训，没记笔记

## 2021.10.10

### **C语言 #0**

**BV1sU4y1w7te**

（从这里开始，我炸了）

##### 基本格式

1. 头文件
```c
#include ""	// 先看程序员目录，后看系统库
#include <>	// 先看系统库，没有才看程序目录
```

2. 花括号{}在定义函数时不可省略

##### 数据类型 

1. 为什么分？省空间 运算快  

2. 123，0123，\0123都表示八进制123

3. float 1 8 23位分别表示符号、数据和指数 ，double为1 9 52

+ 参考IEEE-754
+ 由于指数不需要做加减法，指数用~~原码~~-127=00000000,1=10000000（加127）表示，线性对应便于比较大小。
+ 拆分规则同科学记数法，但是只表示1到2之间的数
+ 精确到6到7位
+ [关于C语言float类型的详细介绍](https://blog.csdn.net/hzw05103020/article/details/50626076?utm_source=app&app_version=4.16.0&code=app_1562916241&uLinkId=usr1mkqgl919blen)

##### 标准输入输出

printf()执行顺序  ***未定义*** （历史原因、编译器自己优化），所以尽量别在printf()里做会改变变量值的计算。

修饰符
+ #用于显示八进制和十六进制前缀
+ +强制显示正数的+
+ -右对齐（与a.b配合使用）
+ \*.\*把*所在地方的数作为参数使用，使代码更灵活或

puts()默认带\n换行，printf()得自己加

缓冲区：
> 产生原因：CPU太快了，输出（输入）比较慢
> 作用：等等再输出（输入）
> 清空条件：
>
> 1. \n
> 2. return（函数结束）
> 3. 满了

返回值：
> scanf()返回读取“数据”个数
> printf()返回s输出“数据”的个数

输出一个百分号：%%

取余运算生搬a正负号

#####  按位运算

移位：

```c
a=a>>2;	// 二进制移位，相当于除以2
b=b<<2;	// 二进制移位，相当于除以2
```



## *2021.10.13

### ** 机器人C语言小讲堂 #0 **

[高程的课件链接](https://pan.baidu.com/s/1NqTNDfAJvr3_r8Ndw7Isww)提取码：tjut

###### 敲代码常见错误（欢迎补充）：

1. “==”和“=”的区别

```C
if(a=0){
    function1();
}
```

2. scanf()引号里不要加奇怪的东西，比如

```C
scanf("%d,%d",&num1,&num2);	// 你输入3 5试试？只能读到3（可怜的scanf()疯狂寻找那个逗号，但是找不到）
```

##### 代码规范

1. 不要用奇奇怪怪的n名称和无意义的字母
2. 写注释

```C
// 这是单行注释
/*
这是多行注释
*/
```

3. const（常变量）的变量名用大写字母，比如

```C
const int MAX=114514;
```

4. 驼峰命名法（还有其他命名方法）

```C
int mathScore;			// 小驼峰，处第一个单词外其他单词首字母大写。用于变量名
int GetAddress(int num)	// 大驼峰，所有单词首字母大写。用于函数名等
```

c++和++c：

> 共同点：实现变量自增
>
> 区别：返回值不同，c++返回自增前的变量，++c返回自增后的变量

逻辑运算中不是0的都是1。

~~左移一位相当于乘2，右移一位相当于除以2。~~这个前面有

##### 数据类型之间的转化

1. 类型不同，取精度高的

   > char < short < int < long < long long
   >
   > float < double <long double
   >
   > signed < 对应的unsigned
   >
   > int < double

2. 强制类型转换

```C
int a=5;
int b=2;
double c;
c=(double)a/(double)b;	// 这次可以看到2.5了
```

##### 调试

> 我不想调试 qwq

1. DevC++的调试  新建项目 > 打断点  > 下一步……
2. 我更喜欢加一些printf();

##### 循环

1. 三大循环

```C
for(int i=0;i>=0;i++){
	functions();
}
// i++发生在函数体执行后（想想i的值是什么时候变的）
// 变量i属于此for循环所有，
while(1){
	functions();
}
// 
do{
	functions();
}while(0);
// 这个至少执行一次
```

2. break用于打破循环，continue用于跳过本轮循环

##### 数组

1. 数组标号从0开始

``` C
int a[6]={0,1,2,3,4};	// 没有a[6],且a[5]为0
for(int i=0;i<6;i++){	// 这里就用起来比较舒服了
    functionns();
}
```

2. 字符数组与字符串

```C
char str1[7]={'z','z','y','y','y','d','s'};	// 字符数组，长度为7
char str2[]="zzyyyds"						// 字符串，长度为6，str[7]='\0'（字符串结束标志，可以用来判断字符串是否结束。
```

3. 数组和指针的py交易

```c
char ch;
scanf("%c",&ch);		// 必须有取地址符&
char str[10];
scanf("%s",str);		// 这里可以没有取地址符&
scanf("%c",&str[0]);	// 这里也必须有取地址符&
// &str等于str，等于&str[0],即数组str的第一个元素在内存中的地址。而str[0]则可以看作一个char.所以必须有&。

int score[5];
int *myScore=score;
myScore[1]=100;			// 没错，可以这么玩（在这里好像没看出来有什么用）
```

## 2021.10.14

### **C语言 #1**

**BV1Jb4y1Y7US**

### 判断与循环

不要这样写

```C
if(10<=x<=20){		// 从左往右判断，相当于(10<=x)<=20
    functions();
}
```

由于编译器的优化，会有奇怪的事情发生。看看这个

```C
int x=10;
if(x<5 && x++){}	// ++不会被执行，因为x<5已经不成立，所以自动忽略后面
// 所以尽量不要把会影响变量值的操作扔到条件表达式里
```

前方高能！！

```C
char N='n'^32	// 大小写转换
char n='N'^32	// 这样也可以
```

EOF的使用

> EOF（End of File），文件结尾标记
>
> EOF仅存在于**文件**结尾，要想在终端输入EOF，Win用Ctrl+Z，MacOS用Ctrl+W，Linux用Ctrl+D。
>
> ```C
> int num;
> if(scanf("%d",&num)!=EOF){
>    	printf("%d",num);
> }
> ```
>

### 排序算法

1. 冒泡排序

> 依次判断当前数和它后面的数的大小关系，不符合要求的进行交换
>
> ```C
> int Sort(int num, int* Num) {
> 	int i,j;
>     int temp;
> 	for(i = num - 1; i > 0; i--) {			// 进行(数目-1)!轮
> 		for(j = 0; j < i; j++) {
> 			if(Num[j]<Num[j+1]) {
> 				temp = Num[j];
> 				Num[j] = Num[j+1];
> 				Num[j+1] = temp;
> 			}
> 		}
> 	}
>     return 0;
> }
> ```
>

2. 选择排序

> 从数组头开始，选择后面比它大（小）的最大（小）的与之交换
>
> ```C
> int Sort(int num, int* Num) {
> 	int i, j;
> 	int mNum, mVue;				//max Value，和Vue没啥关系
> 	for(i = 0; i < num - 1; i++){
> 		mNum = i;	
> 		mVue = Num[i];
> 		for(j = i + 1; j < Num; j++) {
> 			if(mVue < Num[j]) {
> 				mNum = j;
> 				mVue = Num[j];
> 			}
> 		}
> 		if(mVue > Num[i]) {
> 			Num[mNum] = Num[i];
> 			Num[i] = mVue;
> 		}
> 	}
> }
> ```
>

### 数组

数组+1的问题

```C
int num[i][j][k]=[0];				// 这里i,j和k是数字
num[2][3][4]+1 == &(num[2][3][5])	// +sizeof(int)
num+1 == &(num[1][1][0])			// +j*j*sizeof(int)
&num+1 ==&(num[i-1][j-1][k-1]+1)	// +i*j*k*sizeof(int)，直接越界
```

数组初始化

```C
int num[24]={0};	// 使用{}进行初始化，{}里不够的用0
memset(num,1,4);	// 注意匹配问题，memset是在内存层面进行初始化，要初始化的内容需要手动指定
```



## 2021.10.17

### **C语言 #2**

**BV1Bf4y1g7Hm**

cjb的另一条路

> 1. 可以用来快速“查询”的东西有：数组
> 2. 变长数组谨慎使用（不能初始化、先后问题……）

函数的作用：减少代码量、方便维护、功能封装

### 内部函数

> ~~定义在系统库而不是头文件~~我干死你DevC++
>
> 没有头文件函数照样能用，但是数据类型可能有误

### 自定义函数

1. 返回值

> return 结束当前函数并向调用函数的地方返回一个值
>
> 返回值必须与函数原型、函数定义匹配。如果返回值类型为void，需要
>
> ```C
> return ;
> ```

2. 函数的声明与定义

   > 用函数原型声明函数，证明n有这个函数（可以没有形式参数，但要有形参类型）
   >
   > 函数定义才是函数的内容

### 函数使用

> 参数一一对应，不多不漏
>
> 变量作用域和生存期问题（里面定义的变量外面不存在，使用指针访问“不安全”）
>
> 传入的是值，而不是变量（形参和实参的区别）
>
> 只读不写传变量，要写变量传指针
>
> 传数组的方式：
>
> >直接传：
> >  
> > ```C
> > int foo(a[]);
> > 
> > int a[10]={0};
> > foo(a);				// a==&a==&a[0]
> > ```
> >
> > 或者用指针（参考DevC++新建项目时main()函数的参数）
>
>  

### 全局变量与局部变量

|              |    定义方式     |  作用域  |  生存期  | 内存中的位置 |
| :----------: | :-------------: | :------: | :------: | :----------: |
|   全局变量   |  定义在函数外   | 整个程序 | 整个程序 |    数据区    |
|   局部变量   |    代码块内     |  代码块  |  代码块  |     栈区     |
| 静态局部变量 |  static int a;  |  代码块  | 整个程序 |    数据区    |
|  寄存器变量  | restrict int a; |  代码块  |  代码块  |  CPU寄存器   |

### 变量存储位置

> 代码区：函数二进制代码
>
> 数据区：各种常量（代码中提供的字符串属于字符串常量）、静态变量、全局变量
>
> 堆区（大）：malloc()的内存（动态分配）（记得free()）
>
> 栈区（小）：数据（int、double等）
>
> 命令行参数区：shell调用程序时提供的参数

### 函数递归调用

1. 栈

   > 访问原则：先进后出（FILO）
   >
   > 非常小（win下2MB）
   >
   > 参数入栈顺序：
   >
   > > printf()函数参数计算顺序不确定，但参数入栈顺序确定，即从右向左（用于实现可变参数函数）

2. 递归

> 函数调用自己的操作，可以用来解决复杂的问题，但会有很大的时间和空间的开销

3. 尾递归

> 在函数结尾递归，类似循环

## 2021.10.19

### **算法 #0**

**BV1ou411d7Po**

深度学习（Deep Learning）：感知-->推理-->知识-->规划

> 自然语言处理
>
> 计算机视觉
>
> 机器学习

### 算法

> Informally, an algorithm is any well-defined computational procedure that takes some value, or set of values, as input and produces some value, or set of values, as output.

1.  算法的要求

> 正确性
>
> 复杂度小

2. 评判算法优劣：

> f(n)=O(g(n))：∀n>N₀,s.t. f(x)<=c₁g(x)（上界，最坏复杂度）
>
> f(n)=Ω(g(n))：∀n>N₀,s.t. f(x)>=c₂g(x)（下界，最优复杂度）
>
> f(n)=ϴ(g(n))：说明O(g(n))=Ω(g(n))

3. 分治：

> 把复杂的问题拆分成小问题
>
> 比如Karatsuba Multiplication O(n^log3^)
>
> > z=x*y;
> >
> > x=xL\*10^m^+xR; y=yL\*10^m^+yR;
> >
> > zL=xL\*yL; zM=xL\*yR+xR\*yL; xR\*yR
> >
> > z=zL\*10^2m^+zM*10^m^+zR;
> >
> > 升级后 
> >
> > zM=(xL+xR)*(yL+yR)-zL-zR;
> >
> > z=zL\*10^2m^+zM*10^m^+zR;

4. 快速幂

> a^n^ = (a^n/2^)^2^ = ...
>
> 递归求幂，时间复杂度为O(log(n))

5. Fibonacci

