# 科协&机器人培训笔记

这是2021届科技协会培训的笔记&2021计算机4班晚自习培训的笔记，~~禁止外传~~视频都发到B站了，也不用保密了。

## 2021.10.4

**BV1sU4y1w7te**

 第一次培训，没记笔记

## 2021.10.10

### **C语言 #0**

**BV1sU4y1w7te**

（从这里开始，我炸了）

##### 基本格式

1. 头文件
```c
#include ""	// 先看程序员目录，后看系统库
#include <>	// 先看系统库，没有才看程序目录
```

2. 花括号{}在定义函数时不可省略

##### 数据类型 

1. 为什么分？省空间 运算快  

2. 123，0123，\0123都表示八进制123

3. float 1 8 23位分别表示符号、数据和指数 ，double为1 9 52

+ 参考IEEE-754
+ 由于指数不需要做加减法，指数用~~原码~~-127=00000000,1=10000000（加127）表示，线性对应便于比较大小。
+ 拆分规则同科学记数法，但是只表示1到2之间的数
+ 精确到6到7位
+ [关于C语言float类型的详细介绍](https://blog.csdn.net/hzw05103020/article/details/50626076?utm_source=app&app_version=4.16.0&code=app_1562916241&uLinkId=usr1mkqgl919blen)

##### 标准输入输出

printf()执行顺序  ***未定义*** （历史原因、编译器自己优化），所以尽量别在printf()里做会改变变量值的计算。

修饰符
+ #用于显示八进制和十六进制前缀
+ +强制显示正数的+
+ -右对齐（与a.b配合使用）
+ \*.\*把*所在地方的数作为参数使用，使代码更灵活或

puts()默认带\n换行，printf()得自己加

缓冲区：
> 产生原因：CPU太快了，输出（输入）比较慢
> 作用：等等再输出（输入）
> 清空条件：
>
> 1. \n
> 2. return（函数结束）
> 3. 满了

返回值：
> scanf()返回读取“数据”个数
> printf()返回s输出“数据”的个数

输出一个百分号：%%

取余运算生搬a正负号

#####  按位运算

移位：

```c
a=a>>2;	// 二进制移位，相当于除以2
b=b<<2;	// 二进制移位，相当于除以2
```



## *2021.10.13

### ** 机器人C语言小讲堂 #0 **

[高程的课件链接](https://pan.baidu.com/s/1NqTNDfAJvr3_r8Ndw7Isww)提取码：tjut

###### 敲代码常见错误（欢迎补充）：

1. “==”和“=”的区别

```C
if(a=0){
    function1();
}
```

2. scanf()引号里不要加奇怪的东西，比如

```C
scanf("%d,%d",&num1,&num2);	// 你输入3 5试试？只能读到3（可怜的scanf()疯狂寻找那个逗号，但是找不到）
```

##### 代码规范

1. 不要用奇奇怪怪的n名称和无意义的字母
2. 写注释

```C
// 这是单行注释
/*
这是多行注释
*/
```

3. const（常变量）的变量名用大写字母，比如

```C
const int MAX=114514;
```

4. 驼峰命名法（还有其他命名方法）

```C
int mathScore;			// 小驼峰，处第一个单词外其他单词首字母大写。用于变量名
int GetAddress(int num)	// 大驼峰，所有单词首字母大写。用于函数名等
```

c++和++c：

> 共同点：实现变量自增
>
> 区别：返回值不同，c++返回自增前的变量，++c返回自增后的变量

逻辑运算中不是0的都是1。

~~左移一位相当于乘2，右移一位相当于除以2。~~这个前面有

##### 数据类型之间的转化

1. 类型不同，取精度高的

   > char < short < int < long < long long
   >
   > float < double <long double
   >
   > signed < 对应的unsigned
   >
   > int < double

2. 强制类型转换

```C
int a=5;
int b=2;
double c;
c=(double)a/(double)b;	// 这次可以看到2.5了
```

##### 调试

> 我不想调试qwq

1. DevC++的调试  新建项目 > 打断点  > 下一步……
2. 我更喜欢加一些printf();

##### 循环

1. 三大循环

```C
for(int i=0;i>=0;i++){
	functions();
}
// i++发生在函数体执行后（想想i的值是什么时候变的）
// 变量i属于此for循环所有，
while(1){
	functions();
}
// 
do{
	functions();
}while(0);
// 这个至少执行一次
```

2. break用于打破循环，continue用于跳过本轮循环

##### 数组

1. 数组标号从0开始

``` C
int a[6]={0,1,2,3,4};	// 没有a[6],且a[5]为0
for(int i=0;i<6;i++){	// 这里就用起来比较舒服了
    functionns();
}
```

2. 字符数组与字符串

```C
char str1[7]={'z','z','y','y','y','d','s'};	// 字符数组，长度为7
char str2[]="zzyyyds"						// 字符串，长度为6，str[7]='\0'（字符串结束标志，可以用来判断字符串是否结束。
```

3. 数组和指针的py交易

```c
char ch;
scanf("%c",&ch);		// 必须有取地址符&
char str[10];
scanf("%s",str);		// 这里可以没有取地址符&
scanf("%c",&str[0]);	// 这里也必须有取地址符&
// &str等于str，等于&str[0],即数组str的第一个元素在内存中的地址。而str[0]则可以看作一个char.所以必须有&。

int score[5];
int *myScore=score;
myScore[1]=100;			// 没错，可以这么玩（在这里好像没看出来有什么用）
```

## 2021.10.14

### **C语言 #1**

**BV1Jb4y1Y7US**

### 判断与循环

不要这样写

```C
if(10<=x<=20){		// 从左往右判断，相当于(10<=x)<=20
    functions();
}
```

由于编译器的优化，会有奇怪的事情发生。看看这个

```C
int x=10;
if(x<5 && x++){}	// ++不会被执行，因为x<5已经不成立，所以自动忽略后面
// 所以尽量不要把会影响变量值的操作扔到条件表达式里
```

前方高能！！

```C
char N='n'^32	// 大小写转换
char n='N'^32	// 这样也可以
```

EOF的使用

> EOF（End of File），文件结尾标记
>
> EOF仅存在于**文件**结尾，要想在终端输入EOF，Win用Ctrl+Z，MacOS用Ctrl+W，Linux用Ctrl+D。
>
> ```C
> int num;
> if(scanf("%d",&num)!=EOF){
>    	printf("%d",num);
> }
> ```
>

### 排序算法

1. 冒泡排序

> 依次判断当前数和它后面的数的大小关系，不符合要求的进行交换
>
> ```C
> int num[NUM];
> int i;temp;
> for(i=NUM-1;i>0;i--){			// 进行(数目-1)!轮
> 	for(j=0;j<i;j++){
> 		if(num[j]<num[j+1]){
> 			temp=num[j];
> 			num[j]=num[j+1];
> 			num[j+1]=temp;
> 		}	
> 	}
> }
> ```
>

2. 选择排序

> 从数组头开始，选择后面比它大（小）的最大（小）的与之交换
>
> ```C
> int num[NUM];
> int i;j;
> int mNum,mVue;				//max Value，和Vue没啥关系
> for(i=0;i<NUM-1;i++){
> 	mNum=i;	
> 	mVue=num[i];
> 	for(j=i+1;j<NUM;j++){
> 		if(mVue<num[j]){
> 			mNum=j;
> 			mVue=num[j];
> 		}
> 	}
> 	if(mVue>num[i]){
> 		num[mNum]=num[i];
> 		num[i]=mVue;
> 	}
> }
> ```
>

### 数组

数组+1的问题

```C
int num[i][j][k]=[0];				// 这里i,j和k是数字
num[2][3][4]+1 == &(num[2][3][5])	// +sizeof(int)
num+1 == &(num[1][1][0])			// +i*j*sizeof(int)
&num+1 ==&(num[i-1][j-1][k-1]+1)	// +i*j*k*sizeof(int)，直接越界
```

数组初始化

```C
int num[24]={0};	// 使用
memset(num,1,4);	// 注意匹配问题，memset是在内存层面进行初始化，要初始化的内容需要手动指定
```

